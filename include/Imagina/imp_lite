#pragma once

#include <cstdint>
#include "multi-precision"
#include "floating_point"
//#include "floating_point.h"

namespace Imagina::MPLite {
	class im_export Float {
		static constexpr int32_t BufferSize = 7 * sizeof(void*) / sizeof(uint32_t) - 2;
		static_assert(BufferSize > 0);

		union {
			uint32_t Buffer[BufferSize];
			uint32_t *Pointer;
		};
		int32_t Exponent;
		union {
			struct {
				int32_t Size : 31;
				int32_t Sign : 1;
			};
			int32_t SignSize;
		};

		uint32_t *Data() { return (Size > BufferSize) ? Pointer : Buffer; }
		const uint32_t *Data() const { return (Size > BufferSize) ? Pointer : Buffer; }

		static void _Init(Float *x, uint32_t size);

	public:
		static void Init(Float *x, uintptr_t precision);
		static void InitCopy(Float *x, const Float *src);

		static void Clear(Float *x);

		static uintptr_t GetPrecision(const Float *x);
		static void SetPrecision(Float *x, uintptr_t precision);

		static void Set(Float *x, const Float *src);
		static void Copy(Float *x, const Float *src);
		static void SetU32(Float *x, uint32_t u32);
		static void SetDouble(Float *x, double d);
		static void SetFloatF64eI64(Float *x, Imagina::FloatF64eI64 f);
		static void SetString(Float *x, const char *str, int base);

		static double GetDouble(const Float *x);
		static Imagina::FloatF64eI64 GetFloatF64eI64(const Float *x);

		static void MulU32(Float *result, const Float *x, uint32_t y);
		static void U32PowU32(Float *result, uint32_t x, uint32_t y);

		static void Neg(Float *result, const Float *x);
		static void Abs(Float *result, const Float *x);
		static void Add(Float *result, const Float *x, const Float *y);
		static void Sub(Float *result, const Float *x, const Float *y);
		static void Mul(Float *result, const Float *x, const Float *y);
		static void Div(Float *result, const Float *x, const Float *y);

		static bool MagnitudeGreater(const Float *x, const Float *y);

	private:
		inline static void UnsignedSet(Float *x, const Float *src);
		template<bool IsAdd>
		static void UnsignedAddSub(Float *result, const Float *x, const Float *y);
		static void UnsignedAdd(Float *result, const Float *x, const Float *y);
		static void UnsignedSub(Float *result, const Float *x, const Float *y);
	};

	static_assert(sizeof(Float) <= sizeof(void *) * 7);
}

namespace Imagina {
	extern im_export MultiPrecision IMPLite;
}