#pragma once

#include <cmath>
#include <algorithm>
#include <concepts>
#include <limits>
#include <cassert>
#include "numerics"
#include "constants"

namespace Imagina {
	using std::abs;
	using std::max;

	inline FloatF64eI64 abs(FloatF64eI64 x) {
		x.Mantissa = std::abs(x.Mantissa);
		return x;
	}

	inline FloatF64eI64 sqrt(FloatF64eI64 x) {
		FloatF64eI64 Result;
		Result.MantissaI64(x.MantissaI64() + ((x.Exponent & 1) << 52));
		Result.Exponent = x.Exponent >> 1;
		Result.Mantissa = std::sqrt(Result.Mantissa);
		Result.Normalize();
		return Result;
	}

	inline double log(const FloatF64eI64 &n) {
		constexpr double Ln_2 = 0.693147180559945309417;
		return std::log(n.Mantissa) + n.Exponent * Ln_2;
	}

	inline double log2(const FloatF64eI64 &n) {
		return std::log2(n.Mantissa) + n.Exponent;
	}

	inline double log10(const FloatF64eI64 &n) {
		constexpr double Log10_2 = 0.30102999566398119521373889472449;
		return std::log10(n.Mantissa) + n.Exponent * Log10_2;
	}

	inline FloatF64eI64 hypot(FloatF64eI64 x, FloatF64eI64 y) {
		return sqrt(x * x + y * y);
	}

	inline double atan2(FloatF64eI64 y, FloatF64eI64 x) {
		double y2, x2;
		y2 = y.Mantissa;
		x2 = x.Mantissa;

		int64_t ExponentDifference = x.Exponent - y.Exponent;
		if (x.Exponent >= y.Exponent) {
			if (ExponentDifference <= 0x200) {
				reinterpret_cast<int64_t &>(y2) -= ExponentDifference << 52;
			} else {
				y = 0.0;
			}
		} else {
			if (ExponentDifference >= -0x200) {
				reinterpret_cast<int64_t &>(x2) += ExponentDifference << 52;
			} else {
				x = 0.0;
			}
		}
		return std::atan2(y2, x2);
	}

	template<typename T> inline T manhattan_hypot(const T &x, const T &y) {
		return abs(x) + abs(y);
	}

	template<typename T> inline T chebyshev_hypot(const T &x, const T &y) {
		return max(abs(x), abs(y));
	}

	template<typename T> inline T manhattan_norm(const Complex<T> &x) {
		return manhattan_hypot(x.re, x.im);
	}

	template<typename T> inline T chebyshev_norm(const Complex<T> &x) { // FIXME: Rename
		return chebyshev_hypot(x.re, x.im);
	}

	template<std::floating_point T> inline T abs(const Complex<T> &x) {
		return std::hypot(x.re, x.im);
	}

	inline FloatF64eI64 abs(const Complex<FloatF64eI64> &x) {
		return hypot(x.re, x.im);
	}

	template<std::floating_point T> inline T arg(const Complex<T> &x) {
		return std::atan2(x.im, x.re);
	}

	inline FloatF64eI64 arg(const Complex<FloatF64eI64> &x) {
		return atan2(x.im, x.re);
	}

	template<std::floating_point T> inline Complex<T> log(const Complex<T> &x) {
		return { std::log(abs(x)), std::atan2(x.im, x.re) };
	}

	inline Complex<double> log(const Complex<FloatF64eI64> &x) {
		return { log(norm(x)) * Constants::Half, atan2(x.im, x.re) };
	}

	template<typename T1, typename T2>
	T1 lerp(T1 a, T1 b, T2 t) {
		return a * (T2(1) - t) + b * t;
	}

	inline std::pair<double, double> _cmp_abs_common(const Complex<double> &a, const Complex<double> &b) {
		double ar = std::abs(a.re), ai = std::abs(a.im);
		double br = std::abs(b.re), bi = std::abs(b.im);
		double max = std::max(std::max(ar, ai), std::max(br, bi));
		assert(std::isfinite(max));
		double scale = std::bit_cast<double>(std::bit_cast<uint64_t>(std::numeric_limits<double>::max()) - std::bit_cast<uint64_t>(max));

		ar *= scale;
		ai *= scale;
		br *= scale;
		bi *= scale;

		return { ar * ar + ai * ai, br * br + bi * bi };
	}

	inline bool abs_lt(const Complex<double> &a, const Complex<double> &b) {
		auto [abs_a, abs_b] = _cmp_abs_common(a, b);
		return abs_a < abs_b;
	}

	inline bool abs_le(const Complex<double> &a, const Complex<double> &b) {
		auto [abs_a, abs_b] = _cmp_abs_common(a, b);
		return abs_a <= abs_b;
	}

	inline bool abs_gt(const Complex<double> &a, const Complex<double> &b) {
		auto [abs_a, abs_b] = _cmp_abs_common(a, b);
		return abs_a > abs_b;
	}

	inline bool abs_ge(const Complex<double> &a, const Complex<double> &b) {
		auto [abs_a, abs_b] = _cmp_abs_common(a, b);
		return abs_a >= abs_b;
	}

	inline bool abs_lt(const Complex<FloatF64eI64> &a, const Complex<FloatF64eI64> &b) {
		return norm(a) < norm(b);
	}

	inline bool abs_le(const Complex<FloatF64eI64> &a, const Complex<FloatF64eI64> &b) {
		return norm(a) <= norm(b);
	}

	inline bool abs_gt(const Complex<FloatF64eI64> &a, const Complex<FloatF64eI64> &b) {
		return norm(a) > norm(b);
	}

	inline bool abs_ge(const Complex<FloatF64eI64> &a, const Complex<FloatF64eI64> &b) {
		return norm(a) >= norm(b);
	}
}