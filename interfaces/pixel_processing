#pragma once
// This file is automatically generated. To make modifications, please edit interfaces/pixel_processing.i

#include <concepts>
#include <Imagina/interface>

namespace Imagina {
	struct PixelDataInfo;

	class IPixelProcessor;

	template<typename T>
	concept IPixelProcessorImpl = !Imagina::Interface<T> && requires {
		static_cast<void (T:: *)(const PixelDataInfo *info)>(&T::SetInput);
		static_cast<const PixelDataInfo *(T:: *)()>(&T::GetOutputInfo);
		static_cast<void (T:: *)(void *output, void *input) const>(&T::Process);
	};

	template<IPixelProcessorImpl T>
	void _IIG_IPixelProcessor_Release(void *instance) {
		delete (T *)instance;
	}

	template<IPixelProcessorImpl T>
	void _IIG_IPixelProcessor_SetInput(void *instance, const PixelDataInfo *info) {
		return ((T *)instance)->T::SetInput(info);
	}

	template<IPixelProcessorImpl T>
	const PixelDataInfo *_IIG_IPixelProcessor_GetOutputInfo(void *instance) {
		return ((T *)instance)->T::GetOutputInfo();
	}

	template<IPixelProcessorImpl T>
	void _IIG_IPixelProcessor_Process(void *instance, void *output, void *input) {
		return ((T *)instance)->T::Process(output, input);
	}

	struct IPixelProcessorVTable {
		void *reserved = nullptr; // Must be null
		void (*Release)(void *instance);

		void (*SetInput)(void *instance, const PixelDataInfo *info);
		const PixelDataInfo *(*GetOutputInfo)(void *instance);
		void (*Process)(void *instance, void *output, void *input);

		template<IPixelProcessorImpl T>
		static constexpr IPixelProcessorVTable OfType(void (*release)(void *instance) = _IIG_IPixelProcessor_Release<T>) {
			IPixelProcessorVTable result;
			result.Release = release;
			result.SetInput = _IIG_IPixelProcessor_SetInput<T>;
			result.GetOutputInfo = _IIG_IPixelProcessor_GetOutputInfo<T>;
			result.Process = _IIG_IPixelProcessor_Process<T>;

			return result;
		}

		template<IPixelProcessorImpl T>
		static const IPixelProcessorVTable value;
	};

	class IPixelProcessor final {
		mutable void *instance;
		mutable const IPixelProcessorVTable *vTable;

	public:
		IPixelProcessor() = default;
		IPixelProcessor(const IPixelProcessor &) = default;
		IPixelProcessor(IPixelProcessor &&) = default;
		IPixelProcessor(std::nullptr_t) : instance(nullptr), vTable(nullptr) {}

		IPixelProcessor(void *instance, const IPixelProcessorVTable *vTable) : instance(instance), vTable(vTable) {}
		explicit IPixelProcessor(IAny any) : instance(any.instance), vTable((IPixelProcessorVTable *)any.vTable) {}

		template<IPixelProcessorImpl T>
		IPixelProcessor(T &instance) : instance(&instance), vTable(&IPixelProcessorVTable::value<T>) {}

		template<IPixelProcessorImpl T>
		IPixelProcessor(T *instance) : instance(instance), vTable(&IPixelProcessorVTable::value<T>) {}

		IPixelProcessor &operator=(IPixelProcessor &x) { instance = x.instance; vTable = x.vTable; return *this; }
		IPixelProcessor &operator=(std::nullptr_t) { instance = nullptr; vTable = nullptr; return *this; }

		const IPixelProcessor &operator=(const IPixelProcessor &x) const { instance = x.instance; vTable = x.vTable; return *this; }
		const IPixelProcessor &operator=(std::nullptr_t) const { instance = nullptr; vTable = nullptr; return *this; }

		bool operator==(const IPixelProcessor x) const { return instance == x.instance; }
		bool operator!=(const IPixelProcessor x) const { return instance != x.instance; }

		operator IAny() { return IAny(instance, vTable); }
		explicit operator IAny() const { return IAny(instance, vTable); }
		operator bool() const { return instance != nullptr; }

		template<IPixelProcessorImpl T>
		explicit operator T *() { return (T *)instance; }

		void Release() {
			if (!instance) return;
			vTable->Release(instance);
			*this = nullptr;
		}

		void SetInput(const PixelDataInfo *info) {
			return vTable->SetInput(instance, info);
		}

		const PixelDataInfo *GetOutputInfo() {
			return vTable->GetOutputInfo(instance);
		}

		void Process(void *output, void *input) const {
			return vTable->Process(instance, output, input);
		}

		using _IIG_IsInterface = void;
	};
}